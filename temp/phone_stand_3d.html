<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gi√° ƒê·ª° ƒêi·ªán Tho·∫°i 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
        }
        #info h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>üéØ Gi√° ƒê·ª° ƒêi·ªán Tho·∫°i 3D</h2>
        <p>üñ±Ô∏è K√©o chu·ªôt: Xoay</p>
        <p>üîç LƒÉn chu·ªôt: Thu ph√≥ng</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Kh·ªüi t·∫°o scene, camera, renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 4, 8);
        camera.lookAt(0, 2, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // √Ånh s√°ng - tƒÉng ƒë·ªô s√°ng
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Th√™m √°nh s√°ng ph·ª•
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);
        
        // T·∫°o gi√° ƒë·ª° ƒëi·ªán tho·∫°i
        const standGroup = new THREE.Group();
        
        // ƒê·∫ø gi√° ƒë·ª° (h√¨nh ch·ªØ nh·∫≠t ph·∫≥ng) - Nh√¥m tr·∫Øng s√°ng
        const baseGeometry = new THREE.BoxGeometry(4, 0.3, 3);
        const baseMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff,
            roughness: 0.2,
            metalness: 0.8
        });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = 0.15;
        base.castShadow = true;
        base.receiveShadow = true;
        standGroup.add(base);
        
        // Ph·∫ßn d·ª±a ph√≠a sau (t·∫•m ƒë·ª©ng) - Nh√¥m x√°m nh·∫°t
        const backSupportGeometry = new THREE.BoxGeometry(3, 4, 0.3);
        const backSupportMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xd0d0d0,
            roughness: 0.3,
            metalness: 0.7
        });
        const backSupport = new THREE.Mesh(backSupportGeometry, backSupportMaterial);
        backSupport.position.set(0, 2.15, -1.35);
        backSupport.rotation.x = -0.15;
        backSupport.castShadow = true;
        standGroup.add(backSupport);
        
        // Ph·∫ßn ch·∫∑n ph√≠a tr∆∞·ªõc (thanh ngang nh·ªè) - Nh√¥m x√°m v·ª´a
        const frontStopGeometry = new THREE.BoxGeometry(3, 0.3, 0.3);
        const frontStopMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xa8a8a8,
            roughness: 0.35,
            metalness: 0.75
        });
        const frontStop = new THREE.Mesh(frontStopGeometry, frontStopMaterial);
        frontStop.position.set(0, 0.45, 1.2);
        frontStop.castShadow = true;
        standGroup.add(frontStop);
        
        scene.add(standGroup);
        standGroup.position.y = 0.5;
        
        // S√†n
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xcccccc,
            roughness: 0.8
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // ƒêi·ªÅu khi·ªÉn chu·ªôt
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotation = { x: 0, y: 0 };
        let zoom = 8;
        
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                // ƒê·∫£o ng∆∞·ª£c h∆∞·ªõng xoay tr√°i ph·∫£i
                rotation.y -= deltaX * 0.01;
                rotation.x += deltaY * 0.01;
                
                rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom += e.deltaY * 0.01;
            zoom = Math.max(3, Math.min(15, zoom));
        });
        
        // Responsive
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const radius = zoom;
            camera.position.x = radius * Math.sin(rotation.y) * Math.cos(rotation.x);
            camera.position.y = radius * Math.sin(rotation.x) + 2;
            camera.position.z = radius * Math.cos(rotation.y) * Math.cos(rotation.x);
            camera.lookAt(0, 2, 0);
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>